- 다른 사람의 풀이

'''
main idea: 총 경우의 수는 A 볼링공의 개수 * B 볼링공이 될 수 있는 볼링공의 수
볼링공은 똑같은 무게의 볼링공끼리 조합될 수 없다.
한 번 조합됐던 볼링공은 중복될 수 없다.
이미 조합된 볼링공 조합과 무게가 같더라도 선택된 적 없는 index의 볼링공이라면
조합될 수 있다.
'''

n, m = map(int, input().split())
weight = list(map(int, input().split()))

data = [0] * 11  # 무게가 0인 경우는 없으므로 1번째 index부터 담기 위해 *11을 한다.

# 경우의 수를 계산하기 위해 모든 볼링공의 개수를 data에 담아준다.
for w in weight:
    data[w] += 1

answer = 0

# for문은 최대 볼링공 무게인 m만큼만 돌려준다.
for d in range(1, m + 1):
    # B 볼링공이 될 수 있는 볼링공의 수를 계산한다.
    # B 볼링공 = 전체 볼링공의 개수 - A 볼링공의 개수
    n -= data[d]
    # 경우의 수 = A 볼링공의 개수 * B 볼링공이 될 수 있는 볼링공의 경우의 수
    answer += data[d] * n
print(answer)


- 나의 풀이

idea: 탐욕법보다는 완전탐색의 방법으로 해결할 수 있다고 생각했다.
결국, 조합의 개수를 찾는 것이고 같은 무게의 볼링공은 항상 그 개수에 포함되지 않으므로
전체를 돌면서 조합의 개수를 구했다.

n, m = map(int, input().split())
weight = list(map(int, input().split()))

# 조합의 개수 but 같은 무게는 불가
# 같은 무게일 때만 넘기라는 조건 사용

arr = []

for i in range(len(weight)):
    curr = weight[i]
    for j in range(i + 1, len(weight)):
        if curr == weight[j]:
            continue
        else:
            arr.append([curr, weight[j]])
print(len(arr))
