Q. 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단 두 번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다.
1. N에서 1을 뺀다.
2. N에서 K를 나눈다.
N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하는 프로그램을 작성하시오.
INPUT: 25 5     OUTPUT: 2

'''
n % k가 0이 아니면
n -= 1
n % k가 0이면
n // k
'''
#1(myself)
import sys
import time

n, k = map(int, sys.stdin.readline().split())
count = 0

now = time.time()
#n이 1이 되는 순간 반복문에서 탈출할 수 있도록
#while n이 2이상일 동안 실행되도록 한다.
while n > 1:
    #두 개의 연산이 있는데, 그 중 
    #가능하면 나눗셈을 선택하는 것이 최소 연산의 수를 구하는 길이기 때문에
    #n이 k로 완전히 나눠지지 않는다면:
    if n % k != 0:
        #k에 완전히 나눠지는 수를 만들기 위해서
        #n에서 1을 뺀다.
        n -= 1
        #첫 번째 연산 방법을 사용했으므로, count에 횟수를 더해준다.
        count += 1
    #n이 k로 완전히 나눠진다면:
    else:
        #while문을 탈출할 수 있도록
        #n을 k로 나눠준다.
        #한 번 이 가정문에 들어오게 되면
        #n이 1이 될 때까지 계속 이 가정문으로 방문하게 된다.
        n //= k
        #이곳을 방문한 횟수만큼 count에 횟수를 더해준다.
        count += 1    
print(time.time() - now)
#구해진 count 횟수를 출력한다.
print(count)


#2 n이 완전히 나누어 지지 않아 1을 빼야되는 만큼 cnt에 더하는 방식
import sys
import time

n, k = map(int, sys.stdin.readline().rstrip().split())
cnt = 0

now = time.time()
while True:
    #n에 k를 나눈 몫을 p에 저장해놓는다.
    p = n//k
    #n이 k 이하이고, 그 상태에서 k로 나눠졌다면:
    if p == 0:
        break
    #n에 가장 가까운 k의 배수를 찾기위해
    #tmp에 나눈 몫과 k를 곱한 값을 저장해놓는다.
    tmp = p * k
    #예를 들어, n이 18이고 tmp가 16이라면 2가 나오므로
    #cnt에 2가 더해진다.
    cnt = cnt + (n-tmp)
    #차이만큼 cnt에 더해줬으므로, 이제는 완전히 나눠질 수 있도록
    #p값을 n에 집어넣어준다.
    n = p
    #예를 들어, 처음에 n이 18이고 k가 4라고 해보자.
    #처음에 p를 구하기 위해서 우리는 18을 4로 나눠, p에 4라는 값을 얻었다.
    #이 과정의 횟수를 세어주기 위해, cnt에 1을 더해준다.
    cnt += 1

print(time.time() - now)

#n이 k이하의 수로 남아, k로 나눠져서 0이 몫으로 저장돼
#반복문에서 탈출되었을 경우, n이 1이 아닐 수 있는 경우가 있다.
#ex) n = 14, k = 5일 때, n이 2인 상태로 반복문을 탈출하게 된다.
#따라서 n을 마저 1로 만들어 주어야 하기 때문에
#cnt를 출력하기 전에, n - 1만큼의 횟수를 cnt에 더해주어야 한다.
cnt += (n-1)
print(cnt)
