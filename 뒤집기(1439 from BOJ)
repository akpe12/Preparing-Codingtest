Q. 다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 
다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.
문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.

- 나의 풀이

아이디어: 0과 1의 개수를 구하는 것이 아닌, 0의 덩어리와 1의 덩어리의 개수를 비교해야 한다.
그리고 덩어리의 개수가 곧 뒤집는 횟수이기에, 0의 덩어리와 1의 덩어리 중 더 적은 개수의 덩어리를 답으로 출력한다.

덩어리의 개수는 곧 문자열 길이 1개짜리로 바꿨을 때와 같기 때문에
정규표현식의 re.sub를 이용하여 2개 이상 반복되는 0 혹은 1을 1개짜리 0 혹은 1로 바꿔준다.

단점은 역시 비용이라고 생각한다.
정규표현식을 쓰면 확실히 비용이 소요된다.
최대 지수 시간까지 걸릴 수 있다.

import re

s = input()
arr_a = []
arr_b = []

arr_a = re.sub(r"0{2,}", "0", s)
arr_b = re.sub(r"1{2,}", "1", arr_a)

answer = arr_b.count("0") if arr_b.count("0") <= arr_b.count("1") else arr_b.count("1")
# (answer = min(arr_b.count("0"), arr_b.count("1"))도 가능

print(answer)

- 책의 풀이

아이디어: 0에서 1로 혹은 1에서 0으로 바뀔 때의 횟수를 각각 세어준다. 그리고 그 count 수가 더 적은 쪽을 출력한다.
직관적으로 바뀌는 횟수를 세는 거라서 너무나도 좋은 접근 방법이라고 생각한다.

나의 접근 방법보다 좋은 방법은 언제나 존재한다.

s = input()
# for문에서 0에서 1 혹은 1에서 0으로 바뀌는 횟수를 체크한다.
# 횟수를 담기 위해 변수를 초기화한다.
count0 = 0
count1 = 0

# 첫 번째 원소는 for문에서 셀 수가 없다. -1번째 인덱스란 존재하지 않기때문에 

if s[0] == "0":
    count1 += 1
else:
    count0 += 1

'''
index i + 1에 탐색 가능하도록 만들기 위해
len(s) - 1을 사용...
첫 번째 원소는 위에서 처리
두 번째 원소를 처리해주기 위해
아래와 같이 작성하는 이유는
(1, len(s) - 1)로 하면
0번째 인덱스부터 1번째 인덱스까지의 수는 항상
같다고 가정하고 푸는 것과 같은 결과라서 그렇다
0번째 인덱스를 count 계산해주고
0번째 인덱스부터 for문을 돌려야지만
1번째 인덱스부터 count 계산을 해줄 수 있다.
'''

for i in range(len(s) - 1):
    if s[i] != s[i + 1]:
        if s[i + 1] == "1":
            count0 += 1
        else:
            count1 += 1
    print(s[i], s[i + 1
    
print(min(count0, count1))
