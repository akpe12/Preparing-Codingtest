#https://www.acmicpc.net/problem/7576
#첫째 줄 -> row, column
#둘째 줄 ~ -> 토마토 정보(행렬)
#1이면 익은 토마토, 0이면 안 익은 토마토, -1은 빈 칸
#출력:
#처음부터 다 익어있으면, 0
#모두 익지 못한다면, -1
#정상적이면, 다 익는 데 걸리는 최소 일수

#그래프 안에 썩은 토마토가 있는 상황
#1. 익은 토마토가 아예 없어서 시작도 못한 경우 -> -1
#2. 빈 칸 때문에 영향을 주지 못한 경우 -> -1

#그래프 안에 썩은 토마토가 없는 상황
#1. 애초부터 다 익어있는 상태 -> 0
#2. 익는 데 최소 날짜를 출력해야 하는 상황
#시작점이 2개 이상이라면?

import sys
#bfs 구현을 위해 collections.deque을 호출
from collections import deque
input = sys.stdin.readline

#현재 칸에서 상하좌우의 칸을 탐색하기 위해
#상하좌우 정보를 리스트에 저장해둔다.
dx = [1, -1, 0, 0]
dy = [0, 0, -1, 1]

#행렬의 크기와 토마토 상자의 정보(행렬)을 입력 받기
column, row = map(int, input().split())
#해당 칸을 방문했는지 확인하기 위한 리스트
visited = [[False] * column for _ in range(row)]
#최종 출력을 위한 변수 0으로 초기화
days = 0
#익지 않은 토마토가 있는지 없는지 확인하기 위한 bool
#만약 익지 않은 토마토가 없다면, 처음부터 다 익어있는 상태이므로
#문제에 제시된 상황 중 하나인 0을 수월하게 출력하도록 도와준다.
rotten = False
graph = []
#상자 안에 들어있는 토마토의 정보 입력 받기
for i in range(row):
    #i행을 입력받으면서 바로 안 익은 토마토가 있는지 확인하기 위해서
    #일부러 tomatoes list에 입력 받은 정보를 저장해둔다.
    #리스트를 그래프에 append한 후
    #입력 받은 행에 안 익은 토마토가 있으면 바로 True로 rotten의 값을 바꿔주고
    #단 한 번도 안 익은 토마토가 입력되지 않았다면, False가 그대로 rotten에 저장된다.
    tomatoes = list(map(int, input().split()))
    graph.append(tomatoes)
    if 0 in tomatoes:
        rotten = True

#상자 안에 익지 않은 토마토가 있다면:
if rotten:
    #deque을 만든다.
    q = deque()
    #문제에서 알 수 있듯이 고정된 시작점이 없다.
    #그래서, 상자 안에 익은 토마토가 어디에 담겨 있는지 탐색을 하여
    #시작점을 찾아야 한다.
    #!중요한 점은 상자에 토마토가 1개만 담겨 있는다는 보장이 없다는 것이다!
    #이 말은 곧, 시작점이 한 곳이 아닐 경우가 존재한다는 것이다.
    #당황할 필요는 없다.
    #시작점을 q에 한번에 모두 담아놓고 bfs 알고리즘을 시작하면 된다!
    for i in range(row):
        for j in range(column):
            if graph[i][j] == 1:
                q.append((i, j))
    #bfs 과정
    #!또 다른 난관은 하루가 지나는 걸 어떻게 셀 것이냐는 것이다!
    while q:
        x, y = q.popleft()
        if visited[x][y] == False:
            visited[x][y] = True
            for i in range(4):
                nx = x + dx[i]
                ny = y + dy[i]
                if nx >= 0 and nx < row and ny >= 0 and ny < column:
                    if graph[nx][ny] == 0:
                        #이전의 좌표에 있던 값에 +1을 한 값을
                        #새로 찾아갈 좌표에 저장한다면
                        #며칠이 지났는지 셀 수 있다.
                        #대신 시작값이 1(익은 토마토)이었으므로
                        #출력을 할 때, -1을 해주어야 한다.
                        graph[nx][ny] = graph[x][y] + 1
                        q.append((nx, ny))
    #출력
    for i in graph:
        #현재 행의 칸에 안 익은 토마토가 남아있을 경우
        #즉, 상자 안에 든 토마토가 모두 익지 못하는 경우
        if 0 in i:
            days = -1
            break
        #현재 형의 칸에 있던 토마토가 모두 익어있는 경우
        #즉, 상자 안에 든 토마토가 모두 익은 경우
        else:
            days = max(days, max(i))
    if days == -1:
        print(days)
    else:
        print(days - 1)
#상자 안에 익지 않은 토마토가 없다면:
else:
    #날짜가 지날 필요가 없으므로, 0을 출력
    #*상자에 토마토가 무조건 1개 이상 있다는 조건이 명시되어  가능
    print(0)



#시도해본 코드
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, -1, 1]

#행렬과 그래프 정보 입력 받기(토마토 정보)
column, row = map(int, input().split())
visited = [[False] * column for _ in range(row)]
days = 0
count = 0
start = []
graph = []
for _ in range(row):
    tomatoes = list(map(int, input().split()))
    graph.append(tomatoes)
    count += tomatoes.count(0)
    
#days는 q에 원래 있던 요소들이 모두 pop되고
#q가 모두 새로운 요소로 채워지는 순간에 += 1
def bfs(x, y, days):
    q = deque()
    q.append((x, y))
    last = q[-1]
    while q:
        if last not in q:
            days += 1
            last = q[-1]
        x, y = q.popleft()
        if visited[x][y] == False:
            visited[x][y] = True
            for i in range(4):
                nx = x + dx[i]
                ny = y + dy[i]
                if nx >= 0 and nx < row and ny >= 0 and ny < column:
                    if graph[nx][ny] == 0:
                        graph[nx][ny] = 1
                        q.append((nx, ny))
    return days

#시작점은 graph[i][j]가 1일 때만 q에 집어넣는 식으로 하면 될 것 같다.
if count:
    for i in range(row):
        for j in range(column):
            if graph[i][j] == 1:
                days = bfs(i, j, days)

    for i in range(row):
        for j in range(column):
            if graph[i][j] == 0:
                print(-1)
                break
            else:
                print(days)
                break
        break
else:
    print(0)
