#https://www.acmicpc.net/problem/2667

#1(시도해본 코드, 단지 수 고려가 되지 않음.)
import sys

#정사각형 모양의 크기는 N*N이므로 그 값을 size 변수에 저장한다.
size = int(sys.stdin.readline().rstrip())
graph = []
#단지 개수를 저장하기 위한 변수
complexes = 0
dong = 2
#단지별 집의 개수를 저장하기 위한 변수들
second = 0
third = 0
fourth = 0
#단지별 집의 개수를 오름차순으로 출력하기 위한 list
dongs = []


for _ in range(size):
    graph.append(list(map(int, sys.stdin.readline().rstrip())))    

def dfs(x, y, dong):
    if x < 0 or x >= size or y < 0 or y >= size:
        return False
    if graph[x][y] == 1:
        graph[x][y] = dong
        dfs(x - 1, y, dong)
        dfs(x + 1, y, dong)
        dfs(x, y - 1, dong)
        dfs(x, y + 1, dong)
        return True
    return False

for i in range(size):
    for j in range(size):
        if dfs(i, j, dong) == True:
            complexes += 1
            dong += 1
for i in range(size):
    for j in range(size):
        if graph[i][j] == 2:
            second += 1
        elif graph[i][j] == 3:
            third += 1
        elif graph[i][j] == 4:
            fourth += 1
dongs.append(second)
dongs.append(third)
dongs.append(fourth)
dongs.sort()

print(complexes)
for i in dongs:
    if i != 0:
        print(i)
        
#2(최종 코드)
import sys

size = int(sys.stdin.readline().rstrip())
graph = []
complexes = 0
#1 영역이 이미 집이 있는 영역으로 제시가 되어 있어서
#단지는 2단지부터 시작하기로 결정했다.
#단지가 바뀔 때마다 숫자 1을 더해서 단지를 구별해줄 것이기 때문에!
dong = 2
dongs = []

#그래프 입력 받기(집들의 위치 입력 받기)
for _ in range(size):
    graph.append(list(map(int, sys.stdin.readline().rstrip())))    

#dfs의 매개변수로는 x,y 좌표와
#단지를 표시해줄 dong 변수로 설정한다.
def dfs(x, y, dong):
    #탐색 진행 중,
    #matrix 밖 즉, 최대 영역 밖으로 벗어나면
    #False를 반환하며 함수가 종료되도록 한다.
    if x < 0 or x >= size or y < 0 or y >= size:
        return False
    #탐색 진행 중,
    #아파트를 발견하면:
    if graph[x][y] == 1:
        #해당 아파트에 단지 번호를 매겨준다.
        #이는 방문 처리 효과도 내면서
        #단지별 아파트 개수를 셀 떄 용이하다.
        graph[x][y] = dong
        #현재 아파트를 기준으로 상하좌우를 탐색한다.
        dfs(x - 1, y, dong)
        dfs(x + 1, y, dong)
        dfs(x, y - 1, dong)
        dfs(x, y + 1, dong)
        return True
    #아파트를 발견하지 못했으면:
    #함수가 종료된다.
    return False

#함수를 작동시키기 위해서:
for i in range(size):
    for j in range(size):
        #정사각형의 모든 좌표 탐색 중:
        #True가 반환되는 곳이 있을 때마다
        #단지 개수를 저장해두는 complexes 변수에 1을 더해준다.
        #그리고 그때가 바로 다른 단지를 탐색하기 전의 순간이기 때문에
        #탐색을 시작하기 전에 단지별 아파트를 체크해줄 dong 변수에도 1을 더해준다.
        if dfs(i, j, dong) == True:
            complexes += 1
            dong += 1
#2차원 리스트를 1차원 리스트로 변환하는 방법
#이를 활용하여, 아파트 위치 정보를 1차원 리스트로 변환해준다.
graph_list = sum(graph, [])
#단지별 아파트 개수를 count로 세어준다.
for i in range(2, dong):
    counter = graph_list.count(i)
    dongs.append(counter)
#오름차순으로 출력하기 위한 sort() 활용
dongs.sort()

print(complexes)
for i in dongs:
    if i != 0:
        print(i)
