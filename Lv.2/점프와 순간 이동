Q. OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진 아이언 슈트를 개발하여 판매하고 있습니다. 
이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만, 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 
그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다. 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다. 
단, 건전지 사용량을 줄이기 위해 점프로 이동하는 것은 최소로 하려고 합니다. 
아이언 슈트 구매자가 이동하려는 거리 N이 주어졌을 때, 사용해야 하는 건전지 사용량의 최솟값을 return하는 solution 함수를 만들어 주세요.

- 다른 사람의 풀이

나의 idea를 다시 정리하자면, '2로 나누다가 나머지가 생기면 나머지 수 만큼 count를 올려준다."
이진수를 구하는 과정과 동일하다.
여기까지는 생각이 미치지 못했다.
하지만 푼 사람들의 코드를 보니 이진수 함수를 사용하여 간단하게 푼 사람들이 있었다.
나도 그 사람들처럼 생각이 좀 더 유연해질 수 있기를 빈다.

idea: 이진수 계산을 하면서 나온 나머지 1의 개수가 곧 점프를 한 횟수와 같다.
점프를 한 횟수는 곧 건전지를 소모한 정도이므로 이를 답으로 출력해주면 된다.

def solution(n):
    return bin(n).count('1')

- 나의 풀이

혹시나 규칙성이 있는 식이 나올까 해서
10만큼 뛰었을 때의 범위까지 수를 다 펼쳐보았지만
이렇다 할 방법을 찾지 못했다.
그러다가 문득 뜬금 없지만 그리디 문제 중 '1로 만들기'라는 문제가 떠올랐고
그 문제와 비슷하게 이 문제를 풀었더니 해결할 수 있었다.

idea: 순간 이동을 할 때는 건전지를 사용하지 않으나, 점프를 할 때는 건전지를 사용한다.
건전지를 최소로 사용할 수 있는 이동 방법을 구하는 프로그램이므로
점프를 한 횟수만 세어주면 된다.
주어진 수가 0이 될 때까지 나누고 빼주는데, 이때 2로 나눠지지 않으면 1을 차감한다. 그리고 이와 동시에 점프 수 즉, 건전지 소모 수를 세어준다.
반복을 돌다가 0이 되면 종료한다.

def solution(n):
    count = 0
    
    while n > 0:
        if n % 2 == 0:
            n //= 2
        else:
            n -= 1
            count += 1

    return count
