Q. 효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는
(1칸, 1칸, 1칸, 1칸)
(1칸, 2칸, 1칸)
(1칸, 1칸, 2칸)
(2칸, 1칸, 1칸)
(2칸, 2칸)
의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 
멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 
여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.

- 다른 사람의 풀이

내가 풀었던 방식과 같이 피보나치식으로 푼 사람들이 대부분이었지만
아무래도 피보나치는 재귀를 사용하기 때문에
비용이 지수 시간까지 소요되지 않을까 하는 걱정이 들었다.
아니나 다를까, 재귀가 아닌 아래와 같이 팩토리얼로 푼 사람이 있었다.
도대체 어떻게 저런 식을 세울 수 있는 걸까?
많이 풀어보는 게 답이겠지?

import math
def jumpCase(num):
    can2 = num//2 
    answer = 0
    for i in range(can2+1):
        nowLen = num-i
        answer += math.factorial(nowLen)//(math.factorial(i)*math.factorial(nowLen-i))
        
    return answer

- 나의 풀이(피보나치라는 힌트를 얻고 푼 풀이)

아무리 생각해도 다른 방법은 없고, 무조건 숫자끼리의 규칙이 있을 거라고 생각했다.
그래서 1~10까지 나올 수 있는 모든 경우를 펼쳐보고 4시간은 계속 쳐다봤다.
진짜 그냥 쳐다보기만 한 건 아닌데 무슨 규칙성이라고는 보이지를 않아서 너무나도 답답했다.
그리고 나서 힌트를 읽었을 때 딱 한 가지 하지 않은 게 있었다.
바로 나올 수 있는 조합끼리의 합을 구해보지 않은 것이다.
합을 구해봤다면, n의 조합의 크기가 (n-1) + (n-2)라는 것을 알 수 있었을 텐데 말이다...
멍청한 짓이라고 판단해서 해보지 않은 것 같다.

def Jump(n):
    arr = [1, 2, 3]

    if n <= 3:
        return arr[n - 1]
    else:
        temp = 4
        while temp < n:
            arr.append(arr[temp - 2] + arr[temp - 3])
            temp += 1
        return arr[n - 2] + arr[n - 3]

def solution(n):
    answer = Jump(n) % 1234567
    return answer    
