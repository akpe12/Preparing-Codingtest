Q. 1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.
1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.
마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.
앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.
이전에 등장했던 단어는 사용할 수 없습니다.
한 글자인 단어는 인정되지 않습니다.
다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.

- 나의 풀이(다른 사람의 풀이 참고)

정말 다른 사람의 풀이를 참고하기 싫었지만, 결국에는 봐버린 문제다.
내가 짰던 코드는 계속 중복 단어를 검사하는 알고리즘에서 문제를 발생시켰다.
중복단어를 검사하기 위해서 처음에는 count를 사용했다. 이건 무조건 문제가 발생할 수밖에 없다.
다음으로는 prev = i - 1이라고 포인트를 잡아주고 for문을 돌리면서 prev를 바꿔주었다. 이것또한 문제가 발생할 수밖에 없었다.
왜냐하면 사실상 count랑 크게 다를 것 없이, 먼저 죽는 사람을 찾는 것이 아닌 그냥 중복단어를 말한 사람을 찾는 알고리즘이었다.

왜 밑의 풀이에서 사용된 리스트를 사용할 생각을 못했을까싶다.
리스트에 한 개씩 요소를 담아가면서, 중복된 단어가 나오면 바로 그 인덱스를 반환해주는 아이디어가 있는데 왜 떠올리지 못했을까?
다른 복잡한 모듈을 사용하는 것도 아닌데 말이다.
제발 어느 순간에 발전한 나의, 성장한 나의 모습을 발견할 수 있길 바란다.
그날까지 계속해서 달리자. 아니 천천히라도 계속 가자.

import math

def solution(n, words):
    endLetter = words[0][-1]
    wrong = 0
    duplicatedArr = []
    
    for i in range(len(words)):
        if len(words[i]) == 1:
            wrong = i
            break
        if i != 0:
            startLetter = words[i][0]
            if endLetter == startLetter:
                endLetter = words[i][-1]
            else:
                wrong = i
                break
        if words[i] in duplicatedArr:
            wrong = i
            break
        duplicatedArr.append(words[i])

    if wrong == 0:
        return [0,0]
    else:
        num = (wrong + 1) % n
        if num == 0:
            num = n

        reps = (wrong + 1) / n
        reps = math.ceil(reps)

        ans = [num, reps]

        return ans
        
        
사실 47번째 줄은 math모듈을 사용할 필요가 없다. 그냥 46번째 줄에서 wrong // n + 1을 해주면 된다.
이걸 왜 이제 알았을까.
