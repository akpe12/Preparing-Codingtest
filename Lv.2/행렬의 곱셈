- 다른 사람의 풀이

도대체 이게 어떻게 행렬의 곱셈이 될 수 있는 건지
파악하는 데에 시간이 좀 걸렸다.
나는 3중 반복문 방식으로 풀어야겠다고 생각하고 있었어서
이런 방법은 어떻게 떠올릴 수 있는 건지 진짜 궁금할 뿐이다.
매일매일 새로운 걸 풀고 배우니까, 매일매일 멍청하다는 생각이 드는 거다.
그냥 하자.

idea: list comprehension으로 2차원 배열을 만드려면
[이곳 안에 for문을 하나 돌리고] 여기 밖에서 for문을 돌리면 된다.]
안쪽에 있는 반복 횟수가 곧 열이 되고, 밭에서 돌게 되는 반복 횟수가 행이 된다.
들어가기 전, zip(*list)에 대해서 알아보자.
우선 *list를 해주면 리스트가 unpacking이 된다.
여기에 zip()함수를 씌워준 형태인데, zip(*list)를 해주면 그 리스트의 열의 요소가 한 줄씩 출력된다.

그래서 밑의 list comprehension을 설명하자면
ans = [[총합(행의 요소 * 열의 요소 for 행의 요소, 열의 요소 in (행, 열) 여기에서 열은 arr2의 열의 요소들을 의미한다.] 여기에서 행은 arr1의 행의 요소들을 의미한다.]
여기에서 sum은 arr1이 한 타임 돌때마다 실행된다.

arr1 = [[2, 3, 2], [4, 2, 4], [3, 1, 4]]
arr2 = [[5, 4, 3], [2, 4, 1], [3, 1, 1]]

ans = [[sum(a * b for a, b in zip(row, col)) for col in zip(*arr2)] for row in arr1]
print(list(zip(arr1, *arr2)))


- 다른 사람의 풀이

내가 사용한 다른 사람의 풀이이다.
위의 풀이는 이 3중 반복문을 한 줄로 표현해버린 것이다.

arr1 = [[2, 3, 2], [4, 2, 4], [3, 1, 4]]
arr2 = [[5, 4, 3], [2, 4, 1], [3, 1, 1]]
result = [[0 for j in range(len(arr2[0]))] for i in range(len(arr1))]

# 이차원 배열을 곱셈하기 위해서는?
# 이중 반복문을 사용하는 게 맞는 것 같다.
# index는 0부터 해당 arr의 끝 인덱스까지
for k in range(len(arr1)):
    for i in range(len(arr2[0])):
        sum_value = 0
        for j in range(len(arr2)):
            sum_value += arr1[k][j] * arr2[j][i]
            # 위에 나오는 수들을 한 배열에 넣기
        result[k][i] = sum_value
print(result)


혼자 이 문제를 푸는 데 실패한 이유: 가장 큰 실패의 원인은 행렬곱의 순서의 오판이었다.
이 코드를 혼자 짤 때 내가 실제로 행렬곱을 할 때의 과정을 착안하여 코드를 짰다. 그 방식은 A * B라고 하면 나는 B에서 A를 곱하는 식이었고
그러다보니 B의 1열 2열 3열 * A의 1행이 아닌 A의 1행 2행 3행 * B의 1열을 하고 있었다. 그래서 자꾸 결과가 이상했다.
물론 나중에는 결과가 옳게 나오도록 수정할 수 있었으나, 입력 배열을 바꾸니 index error가 떴다.
그래서 다시 코드를 짜는 과정에서 멘탈이 흔들렸고 코드를 짜려고 행렬곱을 하는 과정에서 혼란이 왔다.
그 이후 결국 다른 사람의 풀이를 보고 이해하자고 마음 먹었다.
안타깝고 아쉽다.
2차원 이상의 배열을 만나면 무너지는 모습을 자꾸 보게 되니 약점을 확실히 안 것 같다.
실력이 늘기를 바라기만 하지 말고, 늘리자.
